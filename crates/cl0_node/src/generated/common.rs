// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RuleResult {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(string, tag = "2")]
    pub output: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NodeId {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rule {
    #[prost(oneof = "rule::Kind", tags = "1, 2, 3, 4")]
    pub kind: ::core::option::Option<rule::Kind>,
}
/// Nested message and enum types in `Rule`.
pub mod rule {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Reactive(super::ReactiveRule),
        #[prost(message, tag = "2")]
        Declarative(super::DeclarativeRule),
        #[prost(message, tag = "3")]
        CaseRule(super::CaseRule),
        #[prost(message, tag = "4")]
        FactRule(super::FactRule),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReactiveRule {
    #[prost(message, optional, tag = "1")]
    pub event: ::core::option::Option<PrimitiveEvent>,
    /// Optional, empty = None
    #[prost(message, optional, tag = "2")]
    pub condition: ::core::option::Option<Condition>,
    #[prost(message, optional, tag = "3")]
    pub action: ::core::option::Option<Action>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeclarativeRule {
    /// Optional, empty = None
    #[prost(message, optional, tag = "1")]
    pub premise: ::core::option::Option<Condition>,
    #[prost(oneof = "declarative_rule::Target", tags = "2, 3")]
    pub target: ::core::option::Option<declarative_rule::Target>,
}
/// Nested message and enum types in `DeclarativeRule`.
pub mod declarative_rule {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Target {
        #[prost(message, tag = "2")]
        Cc(super::AtomicCondition),
        #[prost(message, tag = "3")]
        Ct(super::Condition),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CaseRule {
    #[prost(message, optional, tag = "1")]
    pub action: ::core::option::Option<Action>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FactRule {
    #[prost(message, optional, tag = "1")]
    pub condition: ::core::option::Option<AtomicCondition>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
    #[prost(oneof = "action::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<action::Kind>,
}
/// Nested message and enum types in `Action`.
pub mod action {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Primitive(super::PrimitiveEvent),
        #[prost(message, tag = "2")]
        List(super::ActionList),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionList {
    #[prost(oneof = "action_list::Kind", tags = "1, 2, 3")]
    pub kind: ::core::option::Option<action_list::Kind>,
}
/// Nested message and enum types in `ActionList`.
pub mod action_list {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Sequence(super::SequenceAction),
        #[prost(message, tag = "2")]
        Parallel(super::ParallelAction),
        #[prost(message, tag = "3")]
        Alternative(super::AlternativeAction),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SequenceAction {
    #[prost(message, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParallelAction {
    #[prost(message, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AlternativeAction {
    #[prost(message, repeated, tag = "1")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrimitiveEvent {
    #[prost(oneof = "primitive_event::Kind", tags = "1, 2, 3")]
    pub kind: ::core::option::Option<primitive_event::Kind>,
}
/// Nested message and enum types in `PrimitiveEvent`.
pub mod primitive_event {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(string, tag = "1")]
        Trigger(::prost::alloc::string::String),
        #[prost(message, tag = "2")]
        Production(super::AtomicCondition),
        #[prost(message, tag = "3")]
        Consumption(super::AtomicCondition),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Condition {
    #[prost(oneof = "condition::Kind", tags = "1, 2, 3, 4, 5")]
    pub kind: ::core::option::Option<condition::Kind>,
}
/// Nested message and enum types in `Condition`.
pub mod condition {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Atomic(super::AtomicCondition),
        #[prost(message, tag = "2")]
        Not(::prost::alloc::boxed::Box<super::Condition>),
        #[prost(message, tag = "3")]
        Conjunction(super::Conjunction),
        #[prost(message, tag = "4")]
        Disjunction(super::Disjunction),
        #[prost(message, tag = "5")]
        Parentheses(::prost::alloc::boxed::Box<super::Condition>),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Conjunction {
    #[prost(message, repeated, tag = "1")]
    pub conditions: ::prost::alloc::vec::Vec<Condition>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Disjunction {
    #[prost(message, repeated, tag = "1")]
    pub conditions: ::prost::alloc::vec::Vec<Condition>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AtomicCondition {
    #[prost(oneof = "atomic_condition::Kind", tags = "1, 2, 3")]
    pub kind: ::core::option::Option<atomic_condition::Kind>,
}
/// Nested message and enum types in `AtomicCondition`.
pub mod atomic_condition {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Primitive(super::PrimitiveCondition),
        #[prost(message, tag = "2")]
        Compound(super::Compound),
        #[prost(message, tag = "3")]
        Sub(::prost::alloc::boxed::Box<super::SubCompound>),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PrimitiveCondition {
    #[prost(string, tag = "1")]
    pub var_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubCompound {
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "2")]
    pub condition: ::core::option::Option<::prost::alloc::boxed::Box<AtomicCondition>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Compound {
    #[prost(message, repeated, tag = "1")]
    pub rules: ::prost::alloc::vec::Vec<Rule>,
    /// Optional: empty string = None
    #[prost(string, tag = "2")]
    pub alias: ::prost::alloc::string::String,
}
