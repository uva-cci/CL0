import type { AST, TmplAstBoundAttribute, TmplAstElement, TmplAstTextAttribute } from "@angular/compiler";
import type { Rule } from "eslint";
import type { Literal } from "../types/ast.js";
import type { Attributes } from "../types/rule.js";
export declare function getAttributesByAngularElement(ctx: Rule.RuleContext, node: TmplAstElement): (TmplAstBoundAttribute | TmplAstTextAttribute)[];
export declare function getLiteralsByAngularAttribute(ctx: Rule.RuleContext, attribute: TmplAstBoundAttribute | TmplAstTextAttribute, attributes: Attributes): Literal[];
export type Parent = {
    parent: AST;
};
export declare function isInsideConditionalExpressionCondition(ctx: Rule.RuleContext, ast: AST): boolean;
export declare function isInsideLogicalExpressionLeft(ctx: Rule.RuleContext, ast: AST): boolean;
/**
 * The angular parser doesn't provide parent references for all nodes. This function traverses the entire AST
 * to find the parent node of the given AST reference.
 *
 * @param ctx The ESLint rule context.
 * @param astNode The AST node to find the parent for.
 * @returns The parent AST node, or undefined if not found.
 */
export declare function findParent(ctx: Rule.RuleContext, astNode: AST): AST | undefined;
export declare function isAST(ast: unknown): ast is AST;
//# sourceMappingURL=angular.d.ts.map