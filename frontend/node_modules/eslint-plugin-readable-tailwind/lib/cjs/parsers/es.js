"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ES_CONTAINER_TYPES_TO_INSERT_BRACES = exports.ES_CONTAINER_TYPES_TO_REPLACE_QUOTES = void 0;
exports.getLiteralsByESVariableDeclarator = getLiteralsByESVariableDeclarator;
exports.getLiteralsByESCallExpression = getLiteralsByESCallExpression;
exports.getLiteralsByTaggedTemplateExpression = getLiteralsByTaggedTemplateExpression;
exports.getLiteralsByESLiteralNode = getLiteralsByESLiteralNode;
exports.getLiteralsByESMatchers = getLiteralsByESMatchers;
exports.getLiteralsByESNodeAndRegex = getLiteralsByESNodeAndRegex;
exports.getStringLiteralByESStringLiteral = getStringLiteralByESStringLiteral;
exports.getLiteralsByESTemplateLiteral = getLiteralsByESTemplateLiteral;
exports.findParentESTemplateLiteralByESTemplateElement = findParentESTemplateLiteralByESTemplateElement;
exports.getESObjectPath = getESObjectPath;
exports.isESObjectKey = isESObjectKey;
exports.isInsideObjectValue = isInsideObjectValue;
exports.isESSimpleStringLiteral = isESSimpleStringLiteral;
exports.isESStringLike = isESStringLike;
exports.isESTemplateLiteral = isESTemplateLiteral;
exports.isESTemplateElement = isESTemplateElement;
exports.isESNode = isESNode;
exports.isESCallExpression = isESCallExpression;
exports.isESVariableDeclarator = isESVariableDeclarator;
exports.hasESNodeParentExtension = hasESNodeParentExtension;
const readable_tailwind_types_rule_js_1 = require("../types/rule.js");
const readable_tailwind_utils_matchers_js_1 = require("../utils/matchers.js");
const readable_tailwind_utils_regex_js_1 = require("../utils/regex.js");
const readable_tailwind_utils_utils_js_1 = require("../utils/utils.js");
exports.ES_CONTAINER_TYPES_TO_REPLACE_QUOTES = [
    "ArrayExpression",
    "Property",
    "CallExpression",
    "VariableDeclarator",
    "ConditionalExpression",
    "LogicalExpression"
];
exports.ES_CONTAINER_TYPES_TO_INSERT_BRACES = [];
function getLiteralsByESVariableDeclarator(ctx, node, variables) {
    const literals = variables.reduce((literals, variable) => {
        if (!node.init) {
            return literals;
        }
        if (!isESVariableSymbol(node.id)) {
            return literals;
        }
        if ((0, readable_tailwind_utils_matchers_js_1.isVariableName)(variable)) {
            if (!(0, readable_tailwind_utils_utils_js_1.matchesName)(variable, node.id.name)) {
                return literals;
            }
            literals.push(...getLiteralsByESExpression(ctx, [node.init]));
        }
        else if ((0, readable_tailwind_utils_matchers_js_1.isVariableRegex)(variable)) {
            literals.push(...getLiteralsByESNodeAndRegex(ctx, node, variable));
        }
        else if ((0, readable_tailwind_utils_matchers_js_1.isVariableMatchers)(variable)) {
            if (!(0, readable_tailwind_utils_utils_js_1.matchesName)(variable[0], node.id.name)) {
                return literals;
            }
            literals.push(...getLiteralsByESMatchers(ctx, node.init, variable[1]));
        }
        return literals;
    }, []);
    return (0, readable_tailwind_utils_utils_js_1.deduplicateLiterals)(literals);
}
function getLiteralsByESCallExpression(ctx, node, callees) {
    const literals = callees.reduce((literals, callee) => {
        if (!isESCalleeSymbol(node.callee)) {
            return literals;
        }
        if ((0, readable_tailwind_utils_matchers_js_1.isCalleeName)(callee)) {
            if (!(0, readable_tailwind_utils_utils_js_1.matchesName)(callee, node.callee.name)) {
                return literals;
            }
            literals.push(...getLiteralsByESExpression(ctx, node.arguments));
        }
        else if ((0, readable_tailwind_utils_matchers_js_1.isCalleeRegex)(callee)) {
            literals.push(...getLiteralsByESNodeAndRegex(ctx, node, callee));
        }
        else if ((0, readable_tailwind_utils_matchers_js_1.isCalleeMatchers)(callee)) {
            if (!(0, readable_tailwind_utils_utils_js_1.matchesName)(callee[0], node.callee.name)) {
                return literals;
            }
            literals.push(...getLiteralsByESMatchers(ctx, node, callee[1]));
        }
        return literals;
    }, []);
    return (0, readable_tailwind_utils_utils_js_1.deduplicateLiterals)(literals);
}
function getLiteralsByTaggedTemplateExpression(ctx, node, tags) {
    const literals = tags.reduce((literals, tag) => {
        if (!isTaggedTemplateSymbol(node.tag)) {
            return literals;
        }
        if ((0, readable_tailwind_utils_matchers_js_1.isTagName)(tag)) {
            if (tag !== node.tag.name) {
                return literals;
            }
            literals.push(...getLiteralsByESTemplateLiteral(ctx, node.quasi));
        }
        else if ((0, readable_tailwind_utils_matchers_js_1.isTagRegex)(tag)) {
            literals.push(...getLiteralsByESNodeAndRegex(ctx, node, tag));
        }
        else if ((0, readable_tailwind_utils_matchers_js_1.isTagMatchers)(tag)) {
            if (tag[0] !== node.tag.name) {
                return literals;
            }
            literals.push(...getLiteralsByESMatchers(ctx, node, tag[1]));
        }
        return literals;
    }, []);
    return (0, readable_tailwind_utils_utils_js_1.deduplicateLiterals)(literals);
}
function getLiteralsByESLiteralNode(ctx, node) {
    if (isESSimpleStringLiteral(node)) {
        const literal = getStringLiteralByESStringLiteral(ctx, node);
        return literal ? [literal] : [];
    }
    if (isESTemplateLiteral(node)) {
        return getLiteralsByESTemplateLiteral(ctx, node);
    }
    if (isESTemplateElement(node) && hasESNodeParentExtension(node)) {
        const literal = getLiteralByESTemplateElement(ctx, node);
        return literal ? [literal] : [];
    }
    return [];
}
function getLiteralsByESMatchers(ctx, node, matchers) {
    const matcherFunctions = getESMatcherFunctions(matchers);
    const literalNodes = (0, readable_tailwind_utils_matchers_js_1.getLiteralNodesByMatchers)(ctx, node, matcherFunctions);
    const literals = literalNodes.flatMap(literalNode => getLiteralsByESLiteralNode(ctx, literalNode));
    return (0, readable_tailwind_utils_utils_js_1.deduplicateLiterals)(literals);
}
function getLiteralsByESNodeAndRegex(ctx, node, regex) {
    if (!hasESNodeParentExtension(node)) {
        return [];
    }
    return (0, readable_tailwind_utils_regex_js_1.getLiteralsByNodeAndRegex)(ctx, node, regex, {
        getLiteralsByMatchingNode: (node) => {
            if (!isESNode(node)) {
                return;
            }
            if (isESSimpleStringLiteral(node)) {
                const literal = getStringLiteralByESStringLiteral(ctx, node);
                return literal ? [literal] : [];
            }
            if (isESTemplateElement(node) && hasESNodeParentExtension(node)) {
                const templateLiteralNode = findParentESTemplateLiteralByESTemplateElement(node);
                return templateLiteralNode && getLiteralsByESTemplateLiteral(ctx, templateLiteralNode);
            }
        },
        getNodeByRangeStart: (start) => ctx.sourceCode.getNodeByRangeIndex(start),
        getNodeRange: node => isESNode(node) ? [node.range?.[0], node.range?.[1]] : undefined,
        getNodeSourceCode: node => isESNode(node) ? ctx.sourceCode.getText(node) : undefined
    });
}
function getStringLiteralByESStringLiteral(ctx, node) {
    const raw = node.raw;
    if (!raw || !node.loc || !node.range || !node.parent.loc || !node.parent.range) {
        return;
    }
    const line = ctx.sourceCode.lines[node.loc.start.line - 1];
    const quotes = (0, readable_tailwind_utils_utils_js_1.getQuotes)(raw);
    const priorLiterals = findPriorLiterals(ctx, node);
    const content = (0, readable_tailwind_utils_utils_js_1.getContent)(raw, quotes);
    const whitespaces = (0, readable_tailwind_utils_utils_js_1.getWhitespace)(content);
    const indentation = (0, readable_tailwind_utils_utils_js_1.getIndentation)(line);
    const multilineQuotes = getMultilineQuotes(node);
    const supportsMultiline = !isESObjectKey(node);
    return {
        ...quotes,
        ...whitespaces,
        ...multilineQuotes,
        content,
        indentation,
        loc: node.loc,
        priorLiterals,
        range: node.range,
        raw,
        supportsMultiline,
        type: "StringLiteral"
    };
}
function getLiteralByESTemplateElement(ctx, node) {
    const raw = ctx.sourceCode.getText(node);
    if (!raw || !node.loc || !node.range || !node.parent.loc || !node.parent.range) {
        return;
    }
    const line = ctx.sourceCode.lines[node.parent.loc.start.line - 1];
    const quotes = (0, readable_tailwind_utils_utils_js_1.getQuotes)(raw);
    const braces = getBracesByString(ctx, raw);
    const priorLiterals = findPriorLiterals(ctx, node);
    const content = (0, readable_tailwind_utils_utils_js_1.getContent)(raw, quotes, braces);
    const whitespaces = (0, readable_tailwind_utils_utils_js_1.getWhitespace)(content);
    const indentation = (0, readable_tailwind_utils_utils_js_1.getIndentation)(line);
    const multilineQuotes = getMultilineQuotes(node);
    return {
        ...whitespaces,
        ...quotes,
        ...braces,
        ...multilineQuotes,
        content,
        indentation,
        loc: node.loc,
        priorLiterals,
        range: node.range,
        raw,
        supportsMultiline: true,
        type: "TemplateLiteral"
    };
}
function getMultilineQuotes(node) {
    const surroundingBraces = exports.ES_CONTAINER_TYPES_TO_INSERT_BRACES.includes(node.parent.type);
    const multilineQuotes = exports.ES_CONTAINER_TYPES_TO_REPLACE_QUOTES.includes(node.parent.type)
        ? ["`"]
        : [];
    return {
        multilineQuotes,
        surroundingBraces
    };
}
function getLiteralsByESExpression(ctx, args) {
    return args.reduce((acc, node) => {
        if (node.type === "SpreadElement") {
            return acc;
        }
        acc.push(...getLiteralsByESLiteralNode(ctx, node));
        return acc;
    }, []);
}
function getLiteralsByESTemplateLiteral(ctx, node) {
    return node.quasis.map(quasi => {
        if (!hasESNodeParentExtension(quasi)) {
            return;
        }
        return getLiteralByESTemplateElement(ctx, quasi);
    }).filter((literal) => literal !== undefined);
}
function findParentESTemplateLiteralByESTemplateElement(node) {
    if (!hasESNodeParentExtension(node)) {
        return;
    }
    if (node.parent.type === "TemplateLiteral") {
        return node.parent;
    }
    return findParentESTemplateLiteralByESTemplateElement(node.parent);
}
function findPriorLiterals(ctx, node) {
    if (!hasESNodeParentExtension(node)) {
        return;
    }
    const priorLiterals = [];
    let currentNode = node;
    while (hasESNodeParentExtension(currentNode)) {
        const parent = currentNode.parent;
        if (isESCallExpression(parent)) {
            break;
        }
        if (isESVariableDeclarator(parent)) {
            break;
        }
        if (parent.type === "TemplateLiteral") {
            for (const quasi of parent.quasis) {
                if (quasi.range === node.range) {
                    break;
                }
                if (quasi.type === "TemplateElement" && hasESNodeParentExtension(quasi)) {
                    const literal = getLiteralByESTemplateElement(ctx, quasi);
                    if (!literal) {
                        continue;
                    }
                    priorLiterals.push(literal);
                }
            }
        }
        if (parent.type === "TemplateElement") {
            const literal = getLiteralByESTemplateElement(ctx, parent);
            if (!literal) {
                continue;
            }
            priorLiterals.push(literal);
        }
        if (parent.type === "Literal") {
            const literal = getLiteralsByESLiteralNode(ctx, parent);
            if (!literal) {
                continue;
            }
            priorLiterals.push(...literal);
        }
        currentNode = parent;
    }
    return priorLiterals;
}
function getESObjectPath(node) {
    if (!hasESNodeParentExtension(node)) {
        return;
    }
    if (node.type !== "Property" &&
        node.type !== "ObjectExpression" &&
        node.type !== "ArrayExpression" &&
        node.type !== "Identifier" &&
        node.type !== "Literal") {
        return;
    }
    const paths = [];
    if (node.type === "Property") {
        if (node.key.type === "Identifier") {
            paths.unshift(createObjectPathElement(node.key.name));
        }
        else if (node.key.type === "Literal") {
            paths.unshift(createObjectPathElement(node.key.value?.toString() ?? node.key.raw));
        }
        else {
            return "";
        }
    }
    if (isESStringLike(node) && isInsideObjectValue(node)) {
        const property = (0, readable_tailwind_utils_matchers_js_1.findMatchingParentNodes)(node, [(node) => {
                return isESNode(node) && node.type === "Property";
            }])[0];
        return getESObjectPath(property);
    }
    if (isESObjectKey(node)) {
        const property = node.parent;
        return getESObjectPath(property);
    }
    if (node.parent.type === "ArrayExpression" && node.type !== "Property") {
        const index = node.parent.elements.indexOf(node);
        paths.unshift(`[${index}]`);
    }
    paths.unshift(getESObjectPath(node.parent));
    return paths.reduce((paths, currentPath) => {
        if (!currentPath) {
            return paths;
        }
        if (paths.length === 0) {
            return [currentPath];
        }
        if (currentPath.startsWith("[") && currentPath.endsWith("]")) {
            return [...paths, currentPath];
        }
        return [...paths, ".", currentPath];
    }, []).join("");
}
function createObjectPathElement(path) {
    if (!path) {
        return "";
    }
    return path.match(/^[A-Z_a-z]\w*$/)
        ? path
        : `["${path}"]`;
}
function isESObjectKey(node) {
    return (node.parent.type === "Property" &&
        node.parent.parent.type === "ObjectExpression" &&
        node.parent.key === node);
}
function isInsideObjectValue(node) {
    if (!hasESNodeParentExtension(node)) {
        return false;
    }
    // Allow call expressions as object values
    if (isESCallExpression(node)) {
        return false;
    }
    if (node.parent.type === "Property" &&
        node.parent.parent.type === "ObjectExpression" &&
        node.parent.value === node) {
        return true;
    }
    return isInsideObjectValue(node.parent);
}
function isESSimpleStringLiteral(node) {
    return (node.type === "Literal" &&
        "value" in node &&
        typeof node.value === "string");
}
function isESStringLike(node) {
    return isESSimpleStringLiteral(node) || isESTemplateElement(node);
}
function isESTemplateLiteral(node) {
    return node.type === "TemplateLiteral";
}
function isESTemplateElement(node) {
    return node.type === "TemplateElement";
}
function isESNode(node) {
    return (node !== null &&
        typeof node === "object" &&
        "type" in node);
}
function isESCallExpression(node) {
    return node.type === "CallExpression";
}
function isESCalleeSymbol(node) {
    return node.type === "Identifier" && !!node.parent && isESCallExpression(node.parent);
}
function isTaggedTemplateExpression(node) {
    return node.type === "TaggedTemplateExpression";
}
function isTaggedTemplateSymbol(node) {
    return node.type === "Identifier" && !!node.parent && isTaggedTemplateExpression(node.parent);
}
function isESVariableDeclarator(node) {
    return node.type === "VariableDeclarator";
}
function isESVariableSymbol(node) {
    return node.type === "Identifier" && !!node.parent && isESVariableDeclarator(node.parent);
}
function hasESNodeParentExtension(node) {
    return "parent" in node && !!node.parent;
}
function getBracesByString(ctx, raw) {
    const closingBraces = raw.startsWith("}") ? "}" : undefined;
    const openingBraces = raw.endsWith("${") ? "${" : undefined;
    return {
        closingBraces,
        openingBraces
    };
}
function getESMatcherFunctions(matchers) {
    return matchers.reduce((matcherFunctions, matcher) => {
        switch (matcher.match) {
            case readable_tailwind_types_rule_js_1.MatcherType.String: {
                matcherFunctions.push((node) => {
                    if (!isESNode(node)) {
                        return false;
                    }
                    if ((0, readable_tailwind_utils_matchers_js_1.isInsideConditionalExpressionTest)(node)) {
                        return false;
                    }
                    if ((0, readable_tailwind_utils_matchers_js_1.isInsideLogicalExpressionLeft)(node)) {
                        return false;
                    }
                    if (!hasESNodeParentExtension(node)) {
                        return false;
                    }
                    return (!isESObjectKey(node) &&
                        !isInsideObjectValue(node) &&
                        isESStringLike(node));
                });
                break;
            }
            case readable_tailwind_types_rule_js_1.MatcherType.ObjectKey: {
                matcherFunctions.push((node) => {
                    if (!isESNode(node)) {
                        return false;
                    }
                    if ((0, readable_tailwind_utils_matchers_js_1.isInsideConditionalExpressionTest)(node)) {
                        return false;
                    }
                    if ((0, readable_tailwind_utils_matchers_js_1.isInsideLogicalExpressionLeft)(node)) {
                        return false;
                    }
                    if (!hasESNodeParentExtension(node)) {
                        return false;
                    }
                    if (!isESObjectKey(node)) {
                        return false;
                    }
                    const path = getESObjectPath(node);
                    return path && matcher.pathPattern ? (0, readable_tailwind_utils_matchers_js_1.matchesPathPattern)(path, matcher.pathPattern) : true;
                });
                break;
            }
            case readable_tailwind_types_rule_js_1.MatcherType.ObjectValue: {
                matcherFunctions.push((node) => {
                    if (!isESNode(node)) {
                        return false;
                    }
                    if ((0, readable_tailwind_utils_matchers_js_1.isInsideConditionalExpressionTest)(node)) {
                        return false;
                    }
                    if ((0, readable_tailwind_utils_matchers_js_1.isInsideLogicalExpressionLeft)(node)) {
                        return false;
                    }
                    if (!hasESNodeParentExtension(node)) {
                        return false;
                    }
                    if (isESObjectKey(node)) {
                        return false;
                    }
                    if (!isInsideObjectValue(node)) {
                        return false;
                    }
                    if (!isESStringLike(node)) {
                        return false;
                    }
                    const path = getESObjectPath(node);
                    return path && matcher.pathPattern ? (0, readable_tailwind_utils_matchers_js_1.matchesPathPattern)(path, matcher.pathPattern) : true;
                });
                break;
            }
        }
        return matcherFunctions;
    }, []);
}
//# sourceMappingURL=es.js.map