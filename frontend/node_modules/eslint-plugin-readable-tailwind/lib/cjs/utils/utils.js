"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCommonOptions = getCommonOptions;
exports.getWhitespace = getWhitespace;
exports.getQuotes = getQuotes;
exports.getContent = getContent;
exports.splitClasses = splitClasses;
exports.display = display;
exports.augmentMessageWithWarnings = augmentMessageWithWarnings;
exports.splitWhitespaces = splitWhitespaces;
exports.getIndentation = getIndentation;
exports.escapeForRegex = escapeForRegex;
exports.getExactClassLocation = getExactClassLocation;
exports.matchesName = matchesName;
exports.deduplicateLiterals = deduplicateLiterals;
exports.isGenericNodeWithParent = isGenericNodeWithParent;
const readable_tailwind_options_default_options_js_1 = require("../options/default-options.js");
function getCommonOptions(ctx) {
    const attributes = getOption(ctx, "attributes") ?? readable_tailwind_options_default_options_js_1.DEFAULT_ATTRIBUTE_NAMES;
    const callees = getOption(ctx, "callees") ?? readable_tailwind_options_default_options_js_1.DEFAULT_CALLEE_NAMES;
    const variables = getOption(ctx, "variables") ?? readable_tailwind_options_default_options_js_1.DEFAULT_VARIABLE_NAMES;
    const tags = getOption(ctx, "tags") ?? readable_tailwind_options_default_options_js_1.DEFAULT_TAG_NAMES;
    const tailwindConfig = getOption(ctx, "entryPoint") ?? getOption(ctx, "tailwindConfig");
    return {
        attributes,
        callees,
        tags,
        tailwindConfig,
        variables
    };
}
function getOption(ctx, key) {
    return ctx.options[0]?.[key] ?? ctx.settings["eslint-plugin-readable-tailwind"]?.[key] ??
        ctx.settings["readable-tailwind"]?.[key];
}
function getWhitespace(classes) {
    const leadingWhitespace = classes.match(/^\s*/)?.[0];
    const trailingWhitespace = classes.match(/\s*$/)?.[0];
    return { leadingWhitespace, trailingWhitespace };
}
function getQuotes(raw) {
    const openingQuote = raw.at(0);
    const closingQuote = raw.at(-1);
    return {
        closingQuote: closingQuote === "'" || closingQuote === '"' || closingQuote === "`" ? closingQuote : undefined,
        openingQuote: openingQuote === "'" || openingQuote === '"' || openingQuote === "`" ? openingQuote : undefined
    };
}
function getContent(raw, quotes, braces) {
    return raw.substring((quotes?.openingQuote?.length ?? 0) + (braces?.closingBraces?.length ?? 0), raw.length - (quotes?.closingQuote?.length ?? 0) - (braces?.openingBraces?.length ?? 0));
}
function splitClasses(classes) {
    if (classes.trim() === "") {
        return [];
    }
    return classes
        .trim()
        .split(/\s+/);
}
function display(classes) {
    return classes
        .replaceAll(" ", "·")
        .replaceAll("\n", "↵\n")
        .replaceAll("\r", "↩\r")
        .replaceAll("\t", "→");
}
function augmentMessageWithWarnings(message, warnings) {
    if (!warnings || warnings.length === 0) {
        return message;
    }
    return [
        warnings.flatMap(({ option, title, url }) => [
            `⚠️ Warning: ${title}. Option \`${option}\` may be misconfigured.`,
            `Check documentation at ${url}`
        ]).join("\n"),
        message
    ].join("\n\n");
}
function splitWhitespaces(classes) {
    return classes.split(/\S+/);
}
function getIndentation(line) {
    return line.match(/^[\t ]*/)?.[0].length ?? 0;
}
function escapeForRegex(word) {
    return word.replace(/[$()*+.?[\\\]^{|}]/g, "\\$&");
}
function getExactClassLocation(literal, className, lastIndex) {
    const escapedClass = escapeForRegex(className);
    const regex = new RegExp(`(?:^|\\s+)(${escapedClass})(?=\\s+|$)`, "g");
    const [...matches] = literal.content.matchAll(regex);
    const match = lastIndex ? matches.at(-1) : matches.at(0);
    if (match?.index === undefined) {
        return literal.loc;
    }
    const fullMatchIndex = match.index;
    const word = match?.[1];
    const indexOfClass = fullMatchIndex + match[0].indexOf(word);
    const linesUpToStartIndex = literal.content.slice(0, indexOfClass).split("\n");
    const isOnFirstLine = linesUpToStartIndex.length === 1;
    const containingLine = linesUpToStartIndex.at(-1);
    const line = literal.loc.start.line + linesUpToStartIndex.length - 1;
    const column = (isOnFirstLine
        ? literal.loc.start.column + (literal.openingQuote?.length ?? 0)
        : 0) + (containingLine?.length ?? 0);
    return {
        end: {
            column: column + className.length,
            line
        },
        start: {
            column,
            line
        }
    };
}
function matchesName(pattern, name) {
    if (!name) {
        return false;
    }
    const match = name.match(pattern);
    return !!match && match[0] === name;
}
function deduplicateLiterals(literals) {
    return literals.filter((l1, index) => {
        return literals.findIndex(l2 => {
            return l1.content === l2.content &&
                l1.range[0] === l2.range[0] &&
                l1.range[1] === l2.range[1];
        }) === index;
    });
}
function isGenericNodeWithParent(node) {
    return (typeof node === "object" &&
        node !== null &&
        "parent" in node &&
        node.parent !== null &&
        typeof node.parent === "object");
}
//# sourceMappingURL=utils.js.map